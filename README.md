------

# 2025年中国大学生工程实践与创新能力大赛 - 视觉识别与UART通信

> **Project Name**: GC-2025-Vision
> **Author**: Forest Wolves Robot Team (Jees996 / Leexian)
> **Device**: OpenMV Cam H7/Plus

## 🏆 荣誉 & 致谢 (Honors & Disclaimer)

**本项目荣获 2025年中国大学生工程实践与创新能力大赛（北京赛区）二等奖。**

⚠️ **写在前面**：
代码源于备赛期间的实战编写，虽然经过了赛场的检验，但受限于作者当时的水平与时间，在代码规范性、算法鲁棒性上仍有许多不足之处。
* **开源目的**：旨在为后续参加工训赛的同学提供一个基础的视觉方案参考（特别是串口通信与状态机部分）。
* **欢迎斧正**：如果您发现 Bug 或有更优的算法思路，**非常欢迎提交 Issue 或 Pull Request 进行更新与指正！** 让我们共同进步。

---

## 📖 项目简介 (Introduction)

本项目是智能物流/搬运机器人的**视觉识别核心模组**，基于 MicroPython 运行于 OpenMV 平台。它主要承担“眼睛”的角色，负责识别物料、定位坐标，并通过串口（UART）指挥主控（STM32）进行运动抓取。

### 📂 仓库文件说明 (File Description)
本仓库包含两份核心代码，分别用于**实战运行**和**硬件调试**：

| 文件名                    | 类型         | 功能说明                                                     | 适用场景                  |
| :------------------------ | :----------- | :----------------------------------------------------------- | :------------------------ |
| **`Eng-Prac-2025.py`**    | **主程序**   | 比赛用的完整逻辑代码。包含颜色识别、圆环识别、坐标计算及与主控的完整通信状态机。 | **比赛/正式运行**         |
| **`openmv_uart_test.py`** | **调试工具** | **硬件除错专用**。剥离了视觉算法，仅用于测试 OpenMV 与 STM32 的串口连接是否通畅（Ping-Pong 测试）。 | **排查通信故障/测试接线** |

---

## 🛠️ 硬件连接 (Wiring)

**无论是运行主程序还是测试脚本，硬件接线均如下：**

⚠️ **重要提示：务必共地 (GND 相连)，否则通信会出现乱码！**

| OpenMV 引脚 | STM32 / 外部设备 | 说明                      |
| :---------- | :--------------- | :------------------------ |
| **P4 (TX)** | **RX**           | OpenMV 发送 -> STM32 接收 |
| **P5 (RX)** | **TX**           | OpenMV 接收 <- STM32 发送 |
| **GND**     | **GND**          | **信号地参考（必须接）**  |
| VIN         | 5V / 3.3V        | 外部供电（如未连接USB）   |

---







------

## 🟢 第一部分：主程序说明 (`Eng-Prac-2025.py`)



### 1. 核心功能与逻辑 (Core Features & Logic)

- 本系统是整个机器人的视觉中枢，核心逻辑如下：

  #### A. 多模式状态机 (State Switching)

  系统不一直运行单一识别算法，而是根据 STM32 发送的串口指令 `car_state` 动态切换模式，节省算力并防止误识别：

  - **物料抓取模式 (`car_state = 1` 或 `3`)**：
    - 调用 `color_track()`。
    - 遍历 `Goods_thresholds` 列表，识别 **红/绿/蓝** 三色矩形色块。
    - 只有当识别到的颜色与 STM32 要求的任务颜色（`color_number`）一致时，才进行位置解算。
  - **色环定位模式 (`car_state = 2`)**：
    - 调用 `find_green_circles()`。
    - 专门针对场地中的圆环任务点进行霍夫圆检测。

  #### B. 智能定位引导与死区设置 (Positioning & Deadband)

  为了让机械臂或车体精准对准目标，代码建立了一个 **“虚拟瞄准框”**（死区机制）：

  - **原理**：只有当目标中心点 `(x, y)` 完全落入画面中心的设定框内时，才认为“对准了”。这避免了车体在临界点反复震荡（左右摇摆）。
  - **参数修改**：可在代码开头的 `变量` 区域修改以下参数以适应不同机械结构：
    - `center_x = 70` / `center_y = 60`: **瞄准中心点**。根据摄像头安装的俯仰角和左右偏差进行微调（OpenMV QQVGA分辨率中心为 80, 60）。
    - `side_length = 8`: **容差半径（死区大小）**。数值越小，对准精度要求越高，但车体越难停稳；数值越大，越容易对准，但抓取误差变大。
  - **输出逻辑**：
    - **Position Flag**: 仅当 X 和 Y 均在容差范围内时置 `1`（允许抓取）。
    - **Xx**: `0`=居中, `1`=目标偏左, `2`=目标偏右。
    - **Xy**: `0`=居中, `1`=目标偏上, `2`=目标偏下。

  #### C. 环境光抗干扰 (补光系统)

  - **功能**：代码通过 `Timer(2)` 在 **P6 引脚** 输出 PWM 波，控制高亮 LED 补光板。
  - **设置**：在 `main()` 函数中调用 `LED_Bord(80)`，将补光亮度恒定锁定在 80%。
  - **作用**：强行压制环境光干扰（如阴影、赛场灯光不均），确保 LAB 颜色阈值在不同场地下的通用性。

  #### D. 开发者调试模式 (Debug Mode)

  代码内置了可视化的调试功能，方便现场排查问题。

  - **如何开启**：将代码第 42 行修改为 `DEBUG = True`。

  - **开启后的效果**：

    1. **视觉反馈**：IDE 的帧缓冲区（Frame Buffer）画面中心会出现一个 **红色的矩形框**。这就是上面提到的“虚拟瞄准框”，方便肉眼观察物料是否对准。

    2. **数据监控**：IDE 下方的串行终端会实时打印当前接收到的指令和识别状态，例如：

       Plaintext

       ```
       [R, G, B], car_state, change_flag, step
       ```

    3. **注意**：比赛正式上场时建议设为 `False` 以节省串口打印占用的时间资源。





### 2. 供电特别说明 (Power Requirement)

⚠️ 极重要提示：

由于项目使用了高亮补光板以压制环境光：

- **必须使用 5V 供电**：请务必通过 USB 接口或 VIN 引脚接入 5V 电源。
- **禁止使用 3.3V**：3.3V 无法驱动补光板，会导致补光亮度不足甚至系统掉电重启。





### 3. 主程序通信协议 (UART Protocol)

**⚠️ 关键设计说明 (Design Rationale)**：

- **发送机制**：由于 OpenMV (MicroPython) 的底层限制，使用中断发送容易导致资源冲突，因此本项目采用 **轮询阻塞 (Polling/Blocking)** 方式发送数据。
- **抗干扰策略**：工训赛现场电气环境复杂，极易因 GND 接触不良或电机电磁干扰产生串口乱码。因此，本协议摒弃了简单的透传，强制引入 **双帧头 + 帧尾** 进行完整性校验——**“宁可丢包，不可错解”**。
- **改进建议**：当前方案在比赛中够用，但若后续开发时间充裕，强烈建议将校验算法升级为 **CRC-16 (循环冗余校验)**，以获得工业级的通信稳定性。

**协议参数详情：**

- **波特率**: 115200
- **发送 (Tx)**: 帧头 `0xA5 0xA6`，帧尾 `0x5B`。有效载荷包含：抓取允许标志、X/Y 轴位置偏差。
- **接收 (Rx)**: 帧头 `0xDF`。有效载荷包含：3个任务目标颜色的顺序、小车当前运行状态机 (`car_state`)。

*(详细协议定义请参阅代码注释或 `Eng-Prac-2025.py` 源码)*





### 4. 如何部署主程序

1. **阈值校准**: 尽管有补光板辅助，但若比赛现场光线极强，仍建议使用 IDE 的 `Threshold Editor` 微调红绿蓝物料的阈值，并更新到代码中的 `Goods_thresholds` 列表。
2. **脱机运行**: 将 `Eng-Prac-2025.py` 文件重命名为 **`main.py`**，复制到 OpenMV 的 U盘根目录。重新上电后，OpenMV 将自动开启补光并运行程序。

---









## 🟡 第二部分：独立通信模组与调试工具 (`openmv_uart_test.py`)

### 1. 设计初衷：为何要单独剥离？ (Why separate it?)

此文件不仅仅是一个调试脚本，更是一个**高度解耦的 UART 通信模组**。

- **调试救星**：当你遇到“STM32 收不到数据”或“数据乱码”，却无法判断是视觉算法卡死、串口代码写错，还是杜邦线没插好时，请**暂停主程序**，运行此脚本。它是一个纯粹的“发报机”，用于验证硬件链路。
- **方便移植**：OpenMV 的视觉代码通常很复杂，混在一起很难看清通信逻辑。我们将串口发送与接收逻辑单独剥离，**方便大家直接复制此文件到其他项目中**，无需修改视觉代码即可快速建立稳定的通信链路。



### 2. 关键技术说明：抗干扰与阻塞机制 (Technical Rationale)

**⚠️ 为什么协议要设计成这样？** 由于 OpenMV (MicroPython) 底层机制限制，使用串口中断容易引发资源冲突，因此本项目被迫采用 **轮询阻塞 (Polling/Blocking)** 的方式收发数据。这种方式在工训赛等电磁环境复杂的场景（电机干扰、GND 虚焊）下极易出错。

因此，我们在 `openmv_uart_test.py` 及主程序中均采用了以下策略：

- **帧头帧尾强校验**：摒弃裸数据传输，强制使用 `0xA5 A6` 双帧头 + `0x5B` 帧尾。逻辑是 **“宁可丢弃错误包，绝不执行错误指令”**。
- **抗干扰设计**：针对 GND 接触不良或电磁干扰导致的比特翻转（Bit Flip），状态机能有效过滤乱码。
- **改进建议**：当前方案为轻量级校验。若您的项目对安全性要求极高且单片机算力充足，**强烈建议将协议升级为 CRC-16 (循环冗余校验)**。



### 2. 测试协议 (Test Protocol)
此脚本默认发送的是**固定模拟值**，用于 Ping-Pong 测试（验证链路通断）：

| 字节    | Hex 值        | 模拟含义                                 |
| :------ | :------------ | :--------------------------------------- |
| Header  | `0xA5 A6`     | 帧头                                     |
| Payload | `01 01 01 00` | 模拟：允许抓取(01), X偏左(01), Y居中(00) |
| Footer  | `0x5B`        | 帧尾                                     |



#### 🔄 移植指南 (How to Port)

当您将此模组移植到自己的项目中时，**不需要**发送固定的 `0x01`。 请将 `send_data_packet()` 函数中的数字参数替换为您代码中的**实际变量**（如识别到的坐标 `cx`, `cy`）。

- **测试模式 (当前)**:

  Python

  ```
  # 发送固定的测试数据
  send_data_packet(1, 1, 1, 0, 0)
  ```

- **实战模式 (移植后)**:

  Python

  ```
  # 发送您代码里算出来的实际变量
  # 例如：send_data_packet(保留位, 抓取标志, X方向, Y方向, 保留位)
  send_data_packet(1, catch_flag, Xx, Xy, 0)
  ```

> **📚 新手补课指路**： 如果您不知道如何将固定的数字 `1` 换成变量 `Xx` 并传递给函数，这属于 Python 语言中最基础的知识。 请去搜索引擎或 B站 搜索学习关键词：**“Python 基础语法 - 变量与函数参数传递”**。





### 3. 如何进行故障排查 (Troubleshooting)

1. 在 OpenMV IDE 中打开 `openmv_uart_test.py` 并点击运行（绿色播放键）。

2. 打开 IDE 下方的 **串行终端 (Serial Terminal)**。

3.  **观察输出**：
    * **看到 `[TX Send] ...`**：说明 OpenMV 代码运行正常，正在向外发数据。
        * *如果 STM32 还没收到* -> 检查线是不是断了，或者 TX/RX 接反了。
        
    * **看到 `[RX Done] ...`**：说明 OpenMV 成功收到了 STM32 发来的指令。
        * *如果收不到* -> 检查 STM32 是否发送了以 `0xDF` 开头的正确帧头。
        
    * **收到乱码**：99% 是因为没有 **共地 (GND)**。
    
        

---

## ⚠️ 常见注意事项 (Notes)

1.  **光线影响**: 视觉识别对光线极其敏感，每次更换场地都必须重新校准阈值。
2.  **通信同步**: 确保 STM32 端的接收解析代码（状态机）与本项目的协议严格一致。
3.  **对焦**: 记得手动旋转镜头调整焦距，确保物料在图像中清晰锐利。

---
*Copyright © 2025 Jees996 (Leexian) @ BJFU Forestry Wolves. All Rights Reserved.*
